<overview>
エージェントがユーザーができることすべてをできるようにするための構造化された規律。すべてのUIアクションには同等のエージェントツールがあるべきです。これは一度きりのチェックではなく、開発ワークフローに統合された継続的なプラクティスです。

**コア原則:** UIフィーチャーを追加する際は、同じPRで対応するツールを追加する。
</overview>

<why_parity>
## なぜアクションパリティが重要か

**失敗ケース:**
```
ユーザー: 「私の読書フィードにエカテリーナ大帝について何か書いて」
エージェント: 「どのシステムを指していますか？読書フィードの意味がわかりません。」
```

ユーザーはUI経由でフィードに公開できた。しかしエージェントには`publish_to_feed`ツールがなかった。修正はシンプル—ツールを追加。しかしインサイトは深い：

**ユーザーがUI経由で取れるすべてのアクションには、エージェントが呼び出せる同等のツールが必要。**

このパリティがないと：
- ユーザーがエージェントにできないことを依頼する
- エージェントが理解すべき機能について明確化の質問をする
- 直接アプリを使用する場合と比べてエージェントが制限されていると感じる
- ユーザーがエージェントの能力への信頼を失う
</why_parity>

<capability_mapping>
## 能力マップ

UIアクションとエージェントツールの構造化されたマップを維持：

| UIアクション | UI場所 | エージェントツール | システムプロンプト参照 |
|-----------|-------------|------------|-------------------------|
| ライブラリを表示 | ライブラリタブ | `read_library` | 「本とハイライトを表示」 |
| 本を追加 | ライブラリ → 追加 | `add_book` | 「ライブラリに本を追加」 |
| インサイトを公開 | 分析ビュー | `publish_to_feed` | 「フィードタブ用のインサイトを作成」 |
| リサーチを開始 | 本の詳細 | `start_research` | 「ウェブ検索で本をリサーチ」 |
| プロフィールを編集 | 設定 | `write_file(profile.md)` | 「読書プロフィールを更新」 |
| スクリーンショットを撮る | カメラ | N/A（ユーザーアクション） | — |
| ウェブ検索 | チャット | `web_search` | 「インターネットを検索」 |

**機能を追加するたびにこのテーブルを更新。**

### あなたのアプリ用テンプレート

```markdown
# 能力マップ - [あなたのアプリ名]

| UIアクション | UI場所 | エージェントツール | システムプロンプト | ステータス |
|-----------|-------------|------------|---------------|--------|
| | | | | ⚠️ 不足 |
| | | | | ✅ 完了 |
| | | | | 🚫 N/A |
```

ステータスの意味：
- ✅ 完了: ツールが存在し、システムプロンプトに文書化されている
- ⚠️ 不足: UIアクションは存在するがエージェント相当がない
- 🚫 N/A: ユーザー専用アクション（例: 生体認証、カメラキャプチャ）
</capability_mapping>

<parity_workflow>
## アクションパリティワークフロー

### 新機能を追加する際

UIフィーチャーを追加するPRをマージする前に：

```
1. このアクションは何か？
   → 「ユーザーが読書フィードにインサイトを公開できる」

2. エージェントツールは存在するか？
   → ツール定義を確認
   → NOなら: ツールを作成

3. システムプロンプトに文書化されているか？
   → システムプロンプトの能力セクションを確認
   → NOなら: ドキュメントを追加

4. コンテキストは利用可能か？
   → エージェントは「フィード」の意味を知っているか？
   → エージェントは利用可能な本を見れるか？
   → NOなら: コンテキスト注入に追加

5. 能力マップを更新
   → トラッキングドキュメントに行を追加
```

### PRチェックリスト

PRテンプレートに追加：

```markdown
## エージェントネイティブチェックリスト

- [ ] すべての新しいUIアクションに対応するエージェントツールがある
- [ ] 新しい能力を記載してシステムプロンプトを更新
- [ ] エージェントがUIと同じデータにアクセスできる
- [ ] 能力マップを更新
- [ ] 自然言語リクエストでテスト
```
</parity_workflow>

<parity_audit>
## パリティ監査

定期的にアプリのアクションパリティギャップを監査：

### ステップ1: すべてのUIアクションを一覧表示

すべての画面を歩いて、ユーザーができることを一覧表示：

```
ライブラリ画面:
- 本のリストを表示
- 本を検索
- カテゴリでフィルタ
- 新しい本を追加
- 本を削除
- 本の詳細を開く

本の詳細画面:
- 本の情報を表示
- リサーチを開始
- ハイライトを表示
- ハイライトを追加
- 本を共有
- ライブラリから削除

フィード画面:
- インサイトを表示
- 新しいインサイトを作成
- インサイトを編集
- インサイトを削除
- インサイトを共有

設定:
- プロフィールを編集
- テーマを変更
- データをエクスポート
- アカウントを削除
```

### ステップ2: ツールカバレッジを確認

各アクションについて検証：

```
✅ 本のリストを表示    → read_library
✅ 本を検索            → read_library（クエリパラメータ付き）
⚠️ カテゴリでフィルタ  → 不足（read_libraryにフィルタパラメータを追加）
⚠️ 新しい本を追加      → 不足（add_bookツールが必要）
✅ 本を削除            → delete_book
✅ 本の詳細を開く      → read_library（単一の本）

✅ リサーチを開始      → start_research
✅ ハイライトを表示    → read_library（ハイライト含む）
⚠️ ハイライトを追加    → 不足（add_highlightツールが必要）
⚠️ 本を共有           → 不足（または共有がUI専用ならN/A）

✅ インサイトを表示    → read_library（フィード含む）
✅ 新しいインサイトを作成 → publish_to_feed
⚠️ インサイトを編集    → 不足（update_feed_itemツールが必要）
⚠️ インサイトを削除    → 不足（delete_feed_itemツールが必要）
```

### ステップ3: ギャップの優先順位付け

すべてのギャップが同等ではない：

**高優先度（ユーザーがこれを求める）:**
- 新しい本を追加
- コンテンツの作成/編集/削除
- コアワークフローアクション

**中優先度（時々リクエスト）:**
- フィルタ/検索のバリエーション
- エクスポート機能
- 共有機能

**低優先度（エージェント経由で稀にリクエスト）:**
- テーマ変更
- アカウント削除
- UI設定の設定
</parity_audit>

<tool_design_for_parity>
## パリティのためのツール設計

### ツールの粒度をUIの粒度に合わせる

UIに「編集」と「削除」の別々のボタンがある場合、別々のツールを検討：

```typescript
// UIの粒度に合わせる
tool("update_feed_item", { id, content, headline }, ...);
tool("delete_feed_item", { id }, ...);

// vs. 結合（エージェントが発見しにくい）
tool("modify_feed_item", { id, action: "update" | "delete", ... }, ...);
```

### ツール名にユーザーの語彙を使用

```typescript
// 良い: ユーザーが言うことに合わせる
tool("publish_to_feed", ...);  // 「フィードに公開」
tool("add_book", ...);         // 「この本を追加」
tool("start_research", ...);   // 「これをリサーチ」

// 悪い: 技術的な専門用語
tool("create_analysis_record", ...);
tool("insert_library_item", ...);
tool("initiate_web_scrape_workflow", ...);
```

### UIが表示するものを返す

UIが詳細付きの確認を表示するなら、ツールも同様にすべき：

```typescript
// UIが表示: 「'白鯨'をライブラリに追加しました」
// ツールも同じものを返すべき:
tool("add_book", async ({ title, author }) => {
  const book = await library.add({ title, author });
  return {
    text: `「${book.title}」by ${book.author}をライブラリに追加しました (id: ${book.id})`
  };
});
```
</tool_design_for_parity>

<context_parity>
## コンテキストパリティ

ユーザーが見るものは何でも、エージェントもアクセスできるべき。

### 問題

```swift
// UIがリストで最近の分析を表示
ForEach(analysisRecords) { record in
    AnalysisRow(record: record)
}

// しかしシステムプロンプトは本だけを言及し、分析は言及しない
let systemPrompt = """
## 利用可能な本
\(books.map { $0.title })
// 不足: 最近の分析！
"""
```

ユーザーは読書ジャーナルを見る。エージェントは見ない。これが断絶を生む。

### 修正

```swift
// システムプロンプトにUIが表示するものを含める
let systemPrompt = """
## 利用可能な本
\(books.map { "- \($0.title)" }.joined(separator: "\n"))

## 最近の読書ジャーナル
\(analysisRecords.prefix(10).map { "- \($0.summary)" }.joined(separator: "\n"))
"""
```

### コンテキストパリティチェックリスト

アプリの各画面について：
- [ ] この画面はどのデータを表示するか？
- [ ] そのデータはエージェントが利用可能か？
- [ ] エージェントは同じレベルの詳細にアクセスできるか？
</context_parity>

<continuous_parity>
## 時間の経過とともにパリティを維持

### Gitフック / CIチェック

```bash
#!/bin/bash
# pre-commitフック: ツールのない新しいUIアクションをチェック

# 新しいSwiftUI Button/onTapGestureの追加を見つける
NEW_ACTIONS=$(git diff --cached --name-only | xargs grep -l "Button\|onTapGesture")

if [ -n "$NEW_ACTIONS" ]; then
    echo "⚠️  新しいUIアクションが検出されました。対応するエージェントツールを追加しましたか？"
    echo "ファイル: $NEW_ACTIONS"
    echo ""
    echo "チェックリスト:"
    echo "  [ ] 新しいアクションのエージェントツールが存在"
    echo "  [ ] システムプロンプトが新しい能力を文書化"
    echo "  [ ] 能力マップを更新"
fi
```

### 自動パリティテスト

```typescript
// parity.test.ts
describe('Action Parity', () => {
  const capabilityMap = loadCapabilityMap();

  for (const [action, toolName] of Object.entries(capabilityMap)) {
    if (toolName === 'N/A') continue;

    test(`${action} has agent tool: ${toolName}`, () => {
      expect(agentTools.map(t => t.name)).toContain(toolName);
    });

    test(`${toolName} is documented in system prompt`, () => {
      expect(systemPrompt).toContain(toolName);
    });
  }
});
```

### 定期監査

定期レビューをスケジュール：

```markdown
## 月次パリティ監査

1. 今月マージされたすべてのPRをレビュー
2. 各PRで新しいUIアクションを確認
3. 各々のツールカバレッジを検証
4. 能力マップを更新
5. 自然言語リクエストでテスト
```
</continuous_parity>

<examples>
## 実例: フィードギャップ

**Before:** Every Readerにはインサイトが表示されるフィードがあったが、そこに公開するエージェントツールがなかった。

```
ユーザー: 「私の読書フィードにエカテリーナ大帝について何か書いて」
エージェント: 「どのシステムを指していますか？明確にしていただけますか？」
```

**診断:**
- ✅ UIアクション: ユーザーは分析ビューからインサイトを公開できる
- ❌ エージェントツール: `publish_to_feed`ツールがない
- ❌ システムプロンプト: 「フィード」や公開方法の言及なし
- ❌ コンテキスト: エージェントは「フィード」の意味を知らなかった

**修正:**

```swift
// 1. ツールを追加
tool("publish_to_feed",
    "ユーザーの読書フィードにインサイトを公開",
    {
        bookId: z.string().describe("本のID"),
        content: z.string().describe("インサイトの内容"),
        headline: z.string().describe("キャッチーな見出し")
    },
    async ({ bookId, content, headline }) => {
        await feedService.publish({ bookId, content, headline });
        return { text: `「${headline}」を読書フィードに公開しました` };
    }
);

// 2. システムプロンプトを更新
"""
## あなたの能力

- **フィードに公開**: `publish_to_feed`を使用してフィードタブに表示されるインサイトを作成。
  book_id、content、キャッチーなheadlineを含める。
"""

// 3. コンテキスト注入に追加
"""
ユーザーが「フィード」や「読書フィード」と言及した場合、それはインサイトが表示される
フィードタブを意味します。そこにコンテンツを作成するには`publish_to_feed`を使用。
"""
```

**After:**
```
ユーザー: 「私の読書フィードにエカテリーナ大帝について何か書いて」
エージェント: [publish_to_feedを使用してインサイトを作成]
       「完了！『啓蒙された女帝』を読書フィードに公開しました。」
```
</examples>

<checklist>
## アクションパリティチェックリスト

UIの変更があるすべてのPRについて：
- [ ] すべての新しいUIアクションを一覧表示
- [ ] 各アクションにエージェントツールが存在することを検証
- [ ] 新しい能力でシステムプロンプトを更新
- [ ] 能力マップに追加
- [ ] 自然言語リクエストでテスト

定期監査について：
- [ ] すべての画面を歩いた
- [ ] すべての可能なユーザーアクションを一覧表示
- [ ] 各々のツールカバレッジを確認
- [ ] ユーザーリクエストの可能性でギャップに優先順位付け
- [ ] 高優先度ギャップのイシューを作成
</checklist>
