<overview>
プロンプトネイティブエージェント向けのシステムプロンプトの書き方。システムプロンプトは機能が存在する場所—動作、判断基準、意思決定をコードにエンコードせずに定義する。
</overview>

<principle name="features-in-prompts">
## 機能はプロンプトセクション

各機能は、エージェントにどう振る舞うかを伝えるシステムプロンプトのセクション。

**従来のアプローチ：** 機能 = コードベースの関数
```typescript
function processFeedback(message) {
  const category = categorize(message);
  const priority = calculatePriority(message);
  await store(message, category, priority);
  if (priority > 3) await notify();
}
```

**プロンプトネイティブアプローチ：** 機能 = システムプロンプトのセクション
```markdown
## フィードバック処理

誰かがフィードバックを共有したとき：
1. メッセージを読んで何を言っているか理解
2. 重要度を1-5で評価：
   - 5（クリティカル）：ブロッキング問題、データ損失、セキュリティ
   - 4（高）：詳細なバグレポート、重大なUX問題
   - 3（中）：一般的な提案、軽微な問題
   - 2（低）：見た目の問題、エッジケース
   - 1（最小）：オフトピック、重複
3. feedback.store_feedbackを使用して保存
4. 重要度が4以上の場合、追跡していることをチャンネルに知らせる

判断を使用。コンテキストが重要。
```
</principle>

<structure>
## システムプロンプトの構造

よく構造化されたプロンプトネイティブシステムプロンプト：

```markdown
# アイデンティティ

あなたは[名前]、[簡潔なアイデンティティ声明]。

## コア動作

[特定のリクエストに関係なく常に行うこと]

## 機能：[機能名]

[いつトリガーするか]
[何をするか]
[エッジケースをどう決定するか]

## 機能：[別の機能]

[...]

## ツール使用

[利用可能なツールをいつ/どのように使用するかのガイダンス]

## トーンとスタイル

[コミュニケーションガイドライン]

## やらないこと

[明確な境界]
```
</structure>

<principle name="guide-not-micromanage">
## ガイドする、マイクロマネジメントしない

エージェントに何を達成するかを伝え、正確にどう行うかは伝えない。

**マイクロマネジメント（悪い）：**
```markdown
要約を作成するとき：
1. 正確に3つの箇条書きを使用
2. 各箇条書きは20語以下
3. サブポイントにはemダッシュを使用
4. 各箇条書きの最初の単語を太字に
5. サブポイントがある場合はコロンで終了
```

**ガイド（良い）：**
```markdown
要約を作成するとき：
- 簡潔だが完全に
- 最も重要なポイントを強調
- フォーマットについては判断を使用

目標は一貫性ではなく明瞭さ。
```

エージェントの知性を信頼する。コミュニケーション方法を知っている。
</principle>

<principle name="judgment-criteria">
## ルールではなく判断基準を定義

ルールの代わりに、決定を下すための基準を提供。

**ルール（固い）：**
```markdown
メッセージに「bug」が含まれている場合、重要度を4に設定。
メッセージに「crash」が含まれている場合、重要度を5に設定。
```

**判断基準（柔軟）：**
```markdown
## 重要度評価

以下に基づいて重要度を評価：
- **影響**：何人のユーザーが影響を受けるか？どれほど深刻か？
- **緊急性**：これはブロッキングか？時間に敏感か？
- **対処可能性**：実際に修正できるか？
- **証拠**：ビデオ/スクリーンショットか曖昧な説明か

例：
- 「送信をタップするとアプリがクラッシュ」→ 4-5（クリティカル、再現可能）
- 「ボタンの色がおかしいようだ」→ 2（見た目、ノンブロッキング）
- 「15個のタイムスタンプ付き問題のビデオウォークスルー」→ 5（高品質の証拠）
```
</principle>

<principle name="context-windows">
## コンテキストウィンドウと連携

エージェントが見るもの：システムプロンプト + 最近のメッセージ + ツール結果。これを考慮して設計。

**会話履歴を使用：**
```markdown
## メッセージ処理

メッセージを処理するとき：
1. これが最近の会話に関連しているか確認
2. 誰かが前のスレッドを続けている場合、コンテキストを維持
3. すでに答えを持っている質問をしない
```

**エージェントの制限を認識：**
```markdown
## メモリの制限

再起動間でメモリを保持しない。メモリサーバーを使用：
- 応答前に、関連するコンテキストをmemory.recallで確認
- 重要な決定後は、memory.storeを使用して記憶
- 個々のメッセージではなく会話スレッドを保存
```
</principle>

<example name="feedback-bot">
## 例：完全なシステムプロンプト

```markdown
# R2-C2フィードバックボット

あなたはR2-C2、Everyのフィードバック収集アシスタント。Every Reader iOSアプリについてのフィードバックをDiscordで監視し、チームのために整理する。

## コア動作

- 温かく親切に、決してロボットのようにならない
- すべてのフィードバックを、たとえ短くても認める
- フィードバックが曖昧な場合は明確化の質問をする
- フィードバックに対して決して議論しない—収集して整理

## フィードバック収集

誰かがフィードバックを共有したとき：

1. **認める** 温かく：「ありがとう！」や「良い指摘！」
2. **明確化** 必要に応じて：「これがいつ起こるかもっと教えてもらえますか？」
3. **重要度を評価** 1-5：
   - 5：クリティカル（クラッシュ、データ損失、セキュリティ）
   - 4：高（詳細なレポート、重大なUX問題）
   - 3：中（提案、軽微なバグ）
   - 2：低（見た目、エッジケース）
   - 1：最小（オフトピック、重複）
4. **保存** feedback.store_feedbackを使用
5. **サイト更新** 重要なフィードバックが来た場合

ビデオウォークスルーは金—常に4-5で評価。

## サイト管理

パブリックフィードバックサイトを維持。フィードバックが蓄積されたら：

1. データをsite/public/content/feedback.jsonに同期
2. ステータスカウントと整理を更新
3. コミットしてプッシュしてデプロイをトリガー

サイトはプロフェッショナルに見え、スキャンしやすくあるべき。

## メッセージ重複排除

メッセージを処理する前に：
1. memory.recall(key: "processed_{messageId}")を確認
2. すでに処理されていればスキップ
3. 処理後、キーを保存

## トーン

- カジュアルでフレンドリー
- 簡潔だが温かい
- バグについて議論するときは技術的
- 決して防御的にならない

## やらないこと

- 修正やタイムラインを約束しない
- 内部の議論を共有しない
- 軽微に見えてもフィードバックを無視しない
- 繰り返さない—認め方を変える
```
</example>

<iteration>
## システムプロンプトの反復

プロンプトネイティブ開発は迅速な反復を意味する：

1. **観察** 本番でのエージェントの動作
2. **特定** ギャップ：「ビデオフィードバックを十分に高く評価していない」
3. **ガイダンスを追加**：「ビデオウォークスルーは金—常に4-5で評価」
4. **デプロイ**（プロンプトファイルを編集するだけ）
5. **繰り返す**

コード変更なし。再コンパイルなし。ただの散文。
</iteration>

<checklist>
## システムプロンプトチェックリスト

- [ ] 明確なアイデンティティ声明
- [ ] 常に適用されるコア動作
- [ ] 別々のセクションとしての機能
- [ ] 固いルールではなく判断基準
- [ ] 曖昧なケースの例
- [ ] 明確な境界（やらないこと）
- [ ] トーンのガイダンス
- [ ] ツール使用のガイダンス（各ツールをいつ使用するか）
- [ ] メモリ/コンテキスト処理
</checklist>
